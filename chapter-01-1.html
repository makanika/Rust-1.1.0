<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Masterclass - Ch 1: The Full Story (Final Cut)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&family=Source+Sans+3:wght@400;600&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        /* Chosen Palette: Refined Neutral with a touch of deep blue */
        /* Application Structure Plan: A comprehensive, single-chapter e-book that follows the user's 10-point outline. The narrative flows from high-level philosophy and history, to practical comparisons with Python, to motivational examples, to foundational tooling, to core concepts (explained with ELI10 analogies), and finally to a capstone project. This version removes all markdown-style asterisks from the prose. */
        /* Visualization & Content Choices:
        - Report Info: Python vs. Rust mental models. Goal: Compare/Bridge Knowledge. Viz/Presentation: An HTML table clearly contrasting the "unlearn" and "learn" concepts. Interaction: Static visual aid. Justification: Directly addresses the user's background and provides a quick reference for the required mental shifts. Library/Method: Tailwind CSS.
        - Report Info: Ownership & Concurrency. Goal: Explain Simply (ELI10). Viz/Presentation: Specially styled "Analogy" blocks that explain these complex topics using simple metaphors (a keycard for memory, a talking stick for threads). Interaction: Static visual aids. Justification: Analogies are the most effective way to introduce these famously difficult Rust concepts to a beginner. Library/Method: Tailwind CSS.
        - Report Info: Code examples, exercises, and project code. Goal: Practice/Demonstrate. Viz/Presentation: Delineated exercise blocks with collapsible solution sections, now with added inline comments explaining confusing syntax like the dereference operator. Interaction: User performs tasks in their terminal. Justification: Reinforces all theoretical concepts with immediate, hands-on practice. Library/Method: Vanilla JS + Tailwind CSS.
        */
        /* CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. */

        body { font-family: 'Source Sans 3', sans-serif; background-color: #f8f9fa; }
        h1, h2, h3, h4, h5, h6 { font-family: 'Lora', serif; }
        pre code.hljs { font-family: 'Source Code Pro', monospace; }
        .prose { font-size: 1.125rem; line-height: 1.75; }
        .prose strong { color: #1e3a8a; } /* A deep blue for emphasis */
        .nav-link.active { color: #3b82f6; border-bottom-width: 2px; border-color: #3b82f6; }
        .code-block { position: relative; }
        .copy-btn { position: absolute; top: 0.75rem; right: 0.75rem; background-color: #374151; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.8rem; cursor: pointer; opacity: 0; transition: opacity 0.2s, background-color 0.2s; border: 1px solid #4b5563; }
        .copy-btn:hover { background-color: #4b5563; }
        .code-block:hover .copy-btn { opacity: 1; }
        .exercise { background-color: #fefce8; border-left: 4px solid #facc15; padding: 1.5rem; border-radius: 0.5rem; margin: 2rem 0; }
        .analogy-box { background-color: #f0f9ff; border: 2px dashed #7dd3fc; padding: 1.5rem; border-radius: 0.5rem; margin: 2rem 0; }
        details { background-color: #f3f4f6; border-radius: 0.5rem; padding: 1rem; }
        summary { font-weight: 600; cursor: pointer; color: #1f2937; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <header class="bg-white/80 backdrop-blur-lg shadow-sm fixed top-0 left-0 right-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16">
            <div class="flex items-center"><span class="font-bold text-xl text-gray-700">Rust Masterclass: Ch 1 (Final Cut)</span></div>
            <div class="hidden md:block"><nav id="desktop-nav" class="ml-10 flex items-baseline space-x-2">
                <a href="#history" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">History</a>
                <a href="#unlearn" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Un/Learn</a>
                <a href="#excite" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Possibilities</a>
                <a href="#appetite" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Appetizers</a>
                <a href="#tools" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Tools</a>
                <a href="#concepts" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Core Concepts</a>
                <a href="#project" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Project</a>
            </nav></div>
            <div class="-mr-2 flex md:hidden"><button id="mobile-menu-button" class="bg-gray-100 p-2 rounded-md text-gray-500"><svg class="block h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg><svg class="hidden h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg></button></div>
        </div></div>
        <div class="md-hidden hidden" id="mobile-menu"><div class="px-2 pt-2 pb-3 space-y-1 sm:px-3">
            <a href="#history" class="nav-link-mobile block p-2 rounded-md">History</a><a href="#unlearn" class="nav-link-mobile block p-2 rounded-md">Un/Learn</a><a href="#excite" class="nav-link-mobile block p-2 rounded-md">Possibilities</a><a href="#appetite" class="nav-link-mobile block p-2 rounded-md">Appetizers</a><a href="#tools" class="nav-link-mobile block p-2 rounded-md">Tools</a><a href="#concepts" class="nav-link-mobile block p-2 rounded-md">Core Concepts</a><a href="#project" class="nav-link-mobile block p-2 rounded-md">Project</a>
        </div></div>
    </header>

    <main class="pt-24"><div class="max-w-4xl mx-auto p-6 md:p-10">
        <header class="mb-16">
            <p class="text-blue-600 font-semibold">Chapter 1: The Full Story</p>
            <h1 class="text-5xl font-bold text-gray-800 mt-2">From Pythonista to Rustacean: A New Foundation</h1>
            <p class="mt-4 text-xl text-gray-600 max-w-3xl">This is your definitive starting point. We will answer every foundational question, from Rust's origins and philosophy to its most powerful concepts, all through the lens of a Python developer entering the world of systems and embedded engineering.</p>
        </header>

        <article class="space-y-20">
            <section id="history" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">1. A New Hope: Rust's History and Philosophy</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Rust began as a personal project by Graydon Hoare at Mozilla Research in 2006. Mozilla, makers of the Firefox web browser, were dealing with the constant, expensive, and dangerous problem of security vulnerabilities in their C++ codebase. The vast majority of these bugs fell into two categories: memory errors and concurrency issues. They needed a better tool.</p>
                    <p>The project gained momentum, and Rust 1.0 was officially released in <strong>2015</strong> with a powerful mission: to be a language that was <strong>fast, concurrent, and safe</strong>, without compromising on any of them. The philosophy is to empower everyone to build reliable and efficient software. It achieves this by shifting error checking from runtime (when your program is running) to compile time, a concept it calls <strong>"fearless concurrency"</strong> and <strong>"guaranteed memory safety."</strong></p>
                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Can You Skip C/C++ and Become an Embedded Engineer with Rust?</h3>
                    <p><strong>Absolutely, yes.</strong> In 2025, this is not just possible, but increasingly common. While C is the historical lingua franca of embedded systems, it comes with many foot-guns (like manual memory management pitfalls). C++ is more modern but notoriously complex.</p>
                    <p>Rust provides the same low-level control as C/C++—the ability to directly manipulate memory and hardware—but wraps it in a "safe" layer. The compiler prevents you from making the most common memory-related mistakes that plague C codebases. For a modern embedded engineer, starting with Rust and Python is a formidable combination: Python for high-level scripting, prototyping, and data analysis, and Rust for the high-performance, ultra-reliable, close-to-the-metal code running on your ESP32 or Pico W.</p>
                </div>
            </section>
            
            <section id="unlearn" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">2. What to Learn and Unlearn Coming from Python</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Your Python skills are valuable, but to learn Rust effectively, you must consciously unlearn some habits and embrace new mental models.</p>
                    <div class="overflow-x-auto my-8">
                        <table class="w-full text-left border-collapse">
                            <thead><tr class="bg-red-100 border-b-2 border-red-200"><th class="p-4 font-semibold">What to Unlearn (The Python Way)</th></tr></thead>
                            <tbody><tr class="border-b"><td class="p-4"><strong>The Garbage Collector Safety Net:</strong> In Python, you create objects and the garbage collector cleans them up later. You don't think much about who "owns" the memory.</td></tr>
                            <tr class="border-b"><td class="p-4"><strong>Dynamic "Duck" Typing:</strong> "If it walks like a duck and quacks like a duck, it's a duck." You can pass any object to a function and find out at runtime if it has the right methods.</td></tr>
                            <tr><td class="p-4"><strong>Interpreted Workflow:</strong> You write code, you run it immediately. Errors are found when the program executes a faulty line.</td></tr></tbody>
                        </table>
                    </div>
                     <div class="overflow-x-auto my-8">
                        <table class="w-full text-left border-collapse">
                            <thead><tr class="bg-green-100 border-b-2 border-green-200"><th class="p-4 font-semibold">What to Learn (The Rust Way)</th></tr></thead>
                            <tbody><tr class="border-b"><td class="p-4"><strong>Ownership:</strong> You MUST think about memory. Every value has a single "owner." When the owner goes out of scope, the memory is instantly cleaned up. This is Rust's core concept.</td></tr>
                            <tr class="border-b"><td class="p-4"><strong>Strong, Static Typing:</strong> The type of every variable must be known before the program runs. The compiler will not let you mix types, preventing a huge class of runtime errors.</td></tr>
                            <tr><td class="p-4"><strong>The Compiler is Your Partner:</strong> You write code, you ask the compiler to check it. If it compiles, you have a high degree of confidence it's free of many bugs. Learn to love its detailed error messages.</td></tr></tbody>
                        </table>
                    </div>
                </div>
            </section>
            
            <section id="excite" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">3. What Should You Be Excited About?</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Rust is not just a language for tiny microcontrollers. It's a full-spectrum systems language. Here's a taste of what you can build:</p>
                    <ul class="list-disc list-inside space-y-3">
                        <li><strong>Build the Bedrock for Web Services:</strong> You asked if you can build systems for Flask and Django to sit on. Yes! With Rust, you can write blazingly fast web servers, API gateways, load balancers, or even custom database engines. Imagine writing a high-performance data processing service in Rust that your Python web app calls for heavy lifting.</li>
                        <li><strong>Supercharge Your Linux Knowledge:</strong> You can use Rust to interact directly with the Linux kernel. Write tools that parse `/proc` files, manipulate network interfaces with `ioctl` calls, or create high-performance system daemons. It's the modern way to do what was traditionally C's domain.</li>
                        <li><strong>Solve Real Engineering Problems:</strong> In a data center, you could write a Rust service that polls thousands of temperature sensors over Modbus/TCP, aggregates the data in real-time, and serves it to a monitoring dashboard with minimal CPU and memory footprint. Or, build an access control system where the logic on the door controller is written in safe, reliable Rust.</li>
                    </ul>
                </div>
            </section>

             <section id="appetite" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">4 & 5. Wetting Your Appetite: Two Practical Previews</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Talk is cheap. Let's see some code. Don't worry about understanding every line yet; just absorb the possibilities.</p>
                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Appetizer 1: A Rust CLI that Supercharges a Python Script</h3>
                    <p>Imagine you have a Python script that processes data, but it's slow at one specific task: parsing huge log files. You can rewrite that one part in Rust for speed and call it from your Python script. Our Rust tool will count lines in a file, a simple but common task.</p>
                    <div class="code-block"><pre><code class="language-rust">// In a new Rust project `line_counter` with `clap` added...
use clap::Parser;
use std::fs::File;
use std::io::{self, BufRead, BufReader};

#[derive(Parser)]
struct Cli {
    path: std::path::PathBuf,
}

fn main() -> io::Result<()> {
    let args = Cli::parse();
    let file = File::open(args.path)?;
    let reader = BufReader::new(file);

    // This is much faster than Python for large files
    let line_count = reader.lines().count();
    println!("{}", line_count);
    Ok(())
}</code></pre></div>
                    <p>After running `cargo build --release`, you can now call this hyper-fast utility from your shell or a Python script to do the heavy lifting: `./target/release/line_counter /var/log/syslog`.</p>
                    
                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Appetizer 2: A Glimpse of the ESP32</h3>
                    <p>This is what your end goal might look like: making an LED blink on an ESP32. Notice how the code is "bare metal"—there's no OS, and we're talking directly to hardware peripherals.</p>
                     <div class="code-block"><pre><code class="language-rust">// A conceptual example for an ESP32
#![no_std]
#![no_main]

use esp_idf_hal::{prelude::*, gpio::*};
use esp_idf_sys as _; // Link sys library
use std::thread::sleep;
use std::time::Duration;

#[no_mangle]
fn main() {
    // Take ownership of the hardware peripherals
    let peripherals = Peripherals::take().unwrap();
    let pins = peripherals.pins;

    // Configure GPIO pin 4 as an output pin
    let mut led = PinDriver::output(pins.gpio4).unwrap();

    loop {
        led.set_high().unwrap();
        println!("LED ON");
        sleep(Duration::from_millis(500));

        led.set_low().unwrap();
        println!("LED OFF");
        sleep(Duration::from_millis(500));
    }
}</code></pre></div>
                </div>
            </section>
            
            <section id="tools" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">6. Your Toolkit: Cargo, Crates, and More</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                     <p>We've discussed this before, but it's time for the definitive explanation.</p>
                    <ul class="list-disc list-inside space-y-3">
                        <li><strong>`rustc`</strong>: The Rust Compiler. The engine that turns your `.rs` files into machine code. You will rarely call this directly.</li>
                        <li><strong>Cargo</strong>: The Project Manager and Build System. It's the " NMS" for your code. It calls `rustc` for you, manages dependencies, runs tests, and more. It is your primary interface to the Rust world.</li>
                        <li><strong>Crate</strong>: A package of Rust code. It's either a <strong>Binary Crate</strong> (an executable application, like our `net_tool`) or a <strong>Library Crate</strong> (a collection of reusable code, like `clap`). Your projects are composed of crates.</li>
                        <li><strong>`crates.io`</strong>: The official, public repository of crates. It's the central place where you find and download libraries. `cargo add` pulls from here.</li>
                        <li><strong>`rustup`</strong>: The Rust toolchain installer and manager. It installs and updates `rustc`, `cargo`, and other tools. You use it to keep your Rust installation fresh.</li>
                    </ul>
                </div>
            </section>
            
            <section id="concepts" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">7 & 8. Core Concepts, Explained to a 10-Year-Old</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Two ideas make Rust special: how it manages memory and how it handles doing multiple things at once. Let's use simple analogies.</p>
                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Ownership: No Garbage Collector, Just a Magic Keycard</h3>
                    <div class="analogy-box">
                        <h4 class="font-bold text-lg text-sky-900">The Analogy</h4>
                        <p class="mt-2 text-sky-800">Imagine your computer's memory is a hotel with many rooms. In Python, when you need a room (create an object), the hotel gives you one. You use it, and you might give copies of the key to your friends. You don't worry about cleaning it up. A hotel janitor (the Garbage Collector) periodically walks the halls, checks which rooms are empty, and cleans them. This is convenient, but the janitor can sometimes cause brief pauses in the hotel's operation.</p>
                        <p class="mt-2 text-sky-800">In Rust, there is no janitor. Instead, when you need a room, you get a single, magical <strong>Keycard</strong> (Ownership).
                            <ul class="list-disc list-inside mt-2">
                                <li>Only ONE Keycard exists for any room at a time.</li>
                                <li>If you give the Keycard to a friend, you no longer have it. You can't get back into the room. This is called a <strong>move</strong>.</li>
                                <li>When the person holding the Keycard leaves the hotel (goes out of scope), the Keycard instantly vaporizes, and the room cleans itself immediately. No delays, no pauses.</li>
                            </ul>
                        This system is strict, but it means rooms are cleaned up instantly and predictably, and you can never have two people trying to modify the same room's contents at once.
                        </p>
                    </div>
                    <h4>Example: Seeing Ownership in Action</h4>
                    <p>Type this code into `src/main.rs` in a new project and run `cargo check`. It will NOT compile.</p>
                    <div class="code-block"><pre><code class="language-rust">fn main() {
    let access_code = String::from("RST-4-LIFE"); // We create a String, `access_code` gets the Keycard.
    let new_user = access_code; // We give the Keycard to `new_user`. `access_code` no longer has it.

    // This line will fail! `access_code` has no Keycard and can't access the room.
    println!("The old code was: {}", access_code); 
}</code></pre></div>
                    <p>The compiler error `borrow of moved value: access_code` is Rust protecting you. It's enforcing the "one Keycard" rule.</p>
                    
                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Concurrency: No Chaos, Just a Talking Stick</h3>
                     <div class="analogy-box">
                        <h4 class="font-bold text-lg text-sky-900">The Analogy</h4>
                        <p class="mt-2 text-sky-800">Imagine a group of people (threads) trying to write on the same whiteboard (shared data). If everyone tries to write at once, you get unreadable chaos. This is a "data race," a huge problem in concurrent programming.</p>
                        <p class="mt-2 text-sky-800">Other languages might let this happen, or make you manage complicated locks yourself. Rust's approach is to use a "Talking Stick" (a Mutex, or Mutual Exclusion).
                            <ul class="list-disc list-inside mt-2">
                                <li>To write on the whiteboard, you must first ask for the Talking Stick.</li>
                                <li>Only one person can hold the Talking Stick at a time.</li>
                                <li>While you have the stick, you can write on the board safely, knowing no one else will interfere.</li>
                                <li>When you're done, you put the stick back.</li>
                            </ul>
                        The Rust compiler <strong>forces</strong> you to use the Talking Stick rule. It is impossible to even compile code that tries to access the shared data without first acquiring the lock.
                        </p>
                    </div>
                     <h4>Example: Safe Concurrency</h4>
                     <p>This is a more advanced example, but it shows the concept. This code spawns 10 threads, and each one safely increments a shared counter.</p>
                     <div class="code-block"><pre><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    // Arc is a way to share ownership across threads (many people can see the whiteboard)
    // Mutex is the "Talking Stick" that ensures only one writes at a time
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            // Ask for the Talking Stick. This gives us a "guard" to the data.
            let mut num = counter.lock().unwrap(); 
            // The asterisk (*) is the "dereference operator". It says:
            // "I don't want the guard, I want the actual number it's guarding."
            // We use it here to access the inner value and add 1 to it.
            *num += 1; 
        }); // The Talking Stick is automatically returned when `num` goes out of scope
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap(); // Wait for all threads to finish
    }

    // We still need to lock to read the final value, and dereference to get the number.
    println!("Result: {}", *counter.lock().unwrap()); // Final result will always be 10
}</code></pre></div>
                </div>
            </section>
            
            <section id="project" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">9. Chapter Project: Syslog Level Counter</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Let's build a practical CLI tool that combines everything we've learned. This tool will read a log file (like a syslog file from a server) and count the occurrences of different log levels (e.g., INFO, WARNING, ERROR).</p>
                    <div class="exercise">
                        <h4 class="font-bold text-lg text-yellow-900">Your Task: Build a Log Analyzer</h4>
                        <ol class="list-decimal list-inside mt-3 space-y-2 text-yellow-800">
                            <li>Create a new binary crate: `cargo new log_analyzer`.</li>
                            <li>Add the `clap` crate: `cargo add clap --features derive`.</li>
                            <li>Create a sample log file named `sample.log` in the root of your project with this content:
                                <div class="code-block"><pre><code class="language-text">INFO: System startup complete.
INFO: User 'admin' logged in.
WARNING: Disk space is running low on /dev/sda1.
ERROR: Failed to connect to database at 10.0.0.5.
INFO: User 'admin' logged out.
ERROR: Connection to sensor 4 lost.</code></pre></div>
                            </li>
                            <li>Replace `src/main.rs` with the final code below. Read the comments to understand how it works.</li>
                            <li>Build and run your tool!</li>
                        </ol>

                        <h4>Final Code: `src/main.rs`</h4>
                        <div class="code-block"><pre><code class="language-rust">use clap::Parser;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::collections::HashMap;

/// A simple log analyzer to count log levels
#[derive(Parser)]
struct Cli {
    /// The path to the log file to analyze
    log_file: std::path::PathBuf,
}

fn main() -> io::Result<()> {
    let args = Cli::parse();
    let file = File::open(&args.log_file)?;
    let reader = BufReader::new(file);

    // A HashMap is like a Python dictionary. We'll store our counts here.
    let mut level_counts = HashMap::new();

    for line in reader.lines() {
        let line = line?; // Handle potential reading errors
        if let Some(level) = line.split(':').next() {
            // `entry` gives us a reference to the place where the count is (or will be).
            let count = level_counts.entry(level.to_string()).or_insert(0);
            // We use the dereference operator (*) here to access the actual number
            // that `count` refers to, so we can increment it.
            *count += 1;
        }
    }

    println!("Log Level Summary for: {}", args.log_file.display());
    println!("{:-<30}", "");
    for (level, count) in &level_counts {
        println!("{:10}: {}", level, count);
    }

    Ok(())
}
</code></pre></div>
                        <h4>How to Run It</h4>
                        <p>From your terminal, run:</p>
                        <div class="code-block"><pre><code class="language-bash">cargo run -- sample.log</code></pre></div>
                        <p>You should see a nicely formatted summary of the log levels from your sample file.</p>
                    </div>
                </div>
            </section>
            
             <section class="scroll-mt-20 border-t pt-10">
                <h2 class="text-3xl font-bold text-gray-700">10. Final Thoughts and The Road Ahead</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Congratulations. You have just completed the most crucial chapter in your Rust journey. You haven't just learned syntax; you've learned the philosophy, the workflow, and the core ideas that make Rust a revolutionary language. You understand why it was created, what problems it solves, and how its tools and concepts fit together.</p>
                    <p>You now have a solid mental model for Ownership and Concurrency, and you've built a genuinely useful tool that puts these ideas into practice.</p>
                    <p><strong>In the next chapter, "From Bits to Blueprints,"</strong> we will dive into the language itself. We will explore Rust's fundamental data types—integers, floats, booleans, and characters. We will see how Rust represents this data in memory, giving us the fine-grained control necessary to speak directly to hardware and build the foundations of any embedded system.</p>
                </div>
            </section>
        </article>
    </div></main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
            const mobileMenuButton = document.getElementById('mobile-menu-button');
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenuButton.addEventListener('click', () => { mobileMenu.classList.toggle('hidden'); });
            document.querySelectorAll('.nav-link-mobile').forEach(link => { link.addEventListener('click', () => { mobileMenu.classList.add('hidden'); }); });
            document.querySelectorAll('.code-block').forEach(block => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.innerText = 'Copy';
                block.appendChild(button);
                button.addEventListener('click', () => {
                    const code = block.querySelector('pre code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        button.innerText = 'Copied!';
                        setTimeout(() => { button.innerText = 'Copy'; }, 2000);
                    });
                });
            });
            const sections = document.querySelectorAll('main section[id]');
            const navLinks = document.querySelectorAll('#desktop-nav a.nav-link');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${id}`) { link.classList.add('active'); }
                        });
                    }
                });
            }, { rootMargin: "-20% 0px -80% 0px" });
            sections.forEach(section => { observer.observe(section); });
        });
    </script>
</body>
</html>
