<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Masterclass - Ch 4: Building with Digital LEGOs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lora:wght@400;700&family=Source+Sans+3:wght@400;600&family=Source+Code+Pro&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        body { font-family: 'Source Sans 3', sans-serif; background-color: #f8f9fa; }
        h1, h2, h3, h4, h5, h6 { font-family: 'Lora', serif; }
        pre code.hljs { font-family: 'Source Code Pro', monospace; }
        .prose { font-size: 1.125rem; line-height: 1.75; }
        .prose strong { color: #1e3a8a; }
        .nav-link.active { color: #3b82f6; border-bottom-width: 2px; border-color: #3b82f6; }
        .code-block { position: relative; }
        .copy-btn { position: absolute; top: 0.75rem; right: 0.75rem; background-color: #374151; color: white; padding: 0.25rem 0.75rem; border-radius: 0.375rem; font-size: 0.8rem; cursor: pointer; opacity: 0; transition: opacity 0.2s, background-color 0.2s; border: 1px solid #4b5563; }
        .copy-btn:hover { background-color: #4b5563; }
        .code-block:hover .copy-btn { opacity: 1; }
        .analogy-box { background-color: #f0f9ff; border: 2px dashed #7dd3fc; padding: 1.5rem; border-radius: 0.5rem; margin: 2rem 0; }
        .analogy-title { font-family: 'Lora', serif; font-size: 1.25rem; font-weight: bold; color: #0c4a6e; }
        .deep-dive { background-color: #eef2ff; border-left: 4px solid #6366f1; padding: 1.5rem; border-radius: 0.5rem; margin: 2rem 0; }
        .deep-dive-title { font-family: 'Lora', serif; font-size: 1.25rem; font-weight: bold; color: #312e81; }
        details { background-color: #f3f4f6; border-radius: 0.5rem; padding: 1rem; }
        summary { font-weight: 600; cursor: pointer; color: #1f2937; }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <header class="bg-white/80 backdrop-blur-lg shadow-sm fixed top-0 left-0 right-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="flex items-center justify-between h-16">
            <div class="flex items-center"><span class="font-bold text-xl text-gray-700">Rust Masterclass: Chapter 4</span></div>
            <div class="hidden md:block"><nav id="desktop-nav" class="ml-10 flex items-baseline space-x-4">
                <a href="#intro" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Intro</a>
                <a href="#structs" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Structs</a>
                <a href="#enums" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Enums</a>
                <a href="#match" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Match</a>
                <a href="#project" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Project</a>
                <a href="#next" class="nav-link text-gray-600 hover:text-blue-500 px-3 py-2 text-sm font-medium">Next Chapter</a>
            </nav></div>
            <div class="-mr-2 flex md:hidden"><button id="mobile-menu-button" class="bg-gray-100 p-2 rounded-md text-gray-500"><svg class="block h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" /></svg></button></div>
        </div></div>
        <div class="md:hidden hidden" id="mobile-menu"><div class="px-2 pt-2 pb-3 space-y-1 sm:px-3">
             <a href="#intro" class="nav-link-mobile block p-2 rounded-md">Intro</a><a href="#structs" class="nav-link-mobile block p-2 rounded-md">Structs</a><a href="#enums" class="nav-link-mobile block p-2 rounded-md">Enums</a><a href="#match" class="nav-link-mobile block p-2 rounded-md">Match</a><a href="#project" class="nav-link-mobile block p-2 rounded-md">Project</a><a href="#next" class="nav-link-mobile block p-2 rounded-md">Next Chapter</a>
        </div></div>
    </header>

    <main class="pt-24"><div class="max-w-4xl mx-auto p-6 md:p-10">
        <header id="intro" class="mb-16">
            <p class="text-blue-600 font-semibold">Chapter 4: Building with Digital LEGOs</p>
            <h1 class="text-5xl font-bold text-gray-800 mt-2">Structs and Enums for the Young Engineer</h1>
            <p class="mt-4 text-xl text-gray-600 max-w-3xl">In the last chapters, we learned about the basic building materials of Rust: numbers (`u32`), text (`String`), and true/false switches (`bool`). Think of these as the basic LEGO bricks. But you can't build a cool spaceship or a car for an airplane's landing gear with just single bricks. You need to combine them. This chapter is about learning to create your own custom LEGO pieces and instruction manuals. This is the key to building anything complex, from a router to an airplane's flight computer.</p>
        </header>

        <article class="space-y-20">
            <section id="structs" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">1. Structs: Your Personal LEGO Blueprints</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Imagine you want to describe a network interface on a router. It has a name, an IP address, and you need to know if it's turned on. If we only use our basic bricks, it's messy:</p>
                    <div class="code-block"><pre><code class="language-rust">// The messy way...
let name = "GigabitEthernet0/1";
let ip = "192.168.1.1";
let is_on = true;</code></pre></div>
                    <p>These three variables are related, but the computer doesn't know that! You could easily mix up the name of one interface with the IP of another. This is dangerous, especially in an airplane.</p>
                    <p>We need a way to tell the computer: "These three pieces of information belong together as one single thing." For this, we create a blueprint called a <strong>`struct`</strong>.</p>
                    
                    <div class="analogy-box">
                        <h3 class="analogy-title">Analogy: The LEGO Car Blueprint</h3>
                        <p class="mt-2">A `struct` is a list of parts you need to build something.
                        <pre class="bg-gray-100 text-gray-800 p-2 rounded">
Blueprint for LEGO Car:
- 1x Red Body
- 4x Black Wheels
- 2x Clear Headlights</pre>
                        This is our `struct` definition. It doesn't build the car, it just tells you what you need. Then, you can follow the blueprint to build an actual car. That's called an "instance".
                        </p>
                    </div>

                    <p>Here is the blueprint for our network interface:</p>
                    <div class="code-block"><pre><code class="language-rust">
// This is the blueprint.
struct NetworkInterface {
    name: String,
    ip_address: String,
    is_enabled: bool,
}

fn main() {
    // Now we follow the blueprint to build a real interface. This is an "instance".
    let eth0 = NetworkInterface {
        name: String::from("eth0"),
        ip_address: String::from("192.168.1.1"),
        is_enabled: true,
    };

    // Now all the data is bundled together! We access the pieces with a dot.
    println!("Interface {} is ON!", eth0.name);
}</code></pre></div>
                    <p>By bundling the data, we've made our code safer. We can now pass around a single `NetworkInterface` variable, and we know it will always have a name, an IP, and a status together.</p>
                </div>
            </section>

            <section id="methods" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">2. `impl`: The Instruction Manual for Your Blueprint</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>A LEGO blueprint is great, but it's even better with an instruction manual that tells you what you can *do* with the finished model. Can the wheels turn? Can the doors open? In Rust, the instruction manual is called an **`impl`** block (short for implementation).</p>
                    <p>We use `impl` to give our structs actions, which are called **methods**.</p>
                    <div class="code-block"><pre><code class="language-rust">
struct NetworkInterface {
    name: String,
    ip_address: String,
    is_enabled: bool,
}

// This is the instruction manual for our NetworkInterface blueprint.
impl NetworkInterface {
    // Here is an action: "turn off the interface".
    // It needs to change the interface, so we ask for a special "mutable" version of it (`&mut self`).
    fn turn_off(&mut self) {
        self.is_enabled = false;
    }

    // Here is another action: "get a status report".
    // It only needs to look at the interface, not change it, so we ask for a read-only version (`&self`).
    fn get_status_report(&self) -> String {
        if self.is_enabled {
            return format!("{} is UP", self.name);
        } else {
            return format!("{} is DOWN", self.name);
        }
    }
}

fn main() {
    // We must say `mut` here because we plan to call `turn_off`, which changes the interface.
    let mut eth0 = NetworkInterface {
        name: String::from("eth0"),
        ip_address: String::from("192.168.1.1"),
        is_enabled: true,
    };

    println!("{}", eth0.get_status_report()); // Prints "eth0 is UP"
    eth0.turn_off(); // We follow the "turn off" instruction.
    println!("{}", eth0.get_status_report()); // Prints "eth0 is DOWN"
}</code></pre></div>
                    <p>Think of `&self` as "I need to look at the LEGO model" and `&mut self` as "I need to change the LEGO model (like turning its wheels)". The compiler makes sure you ask for the right kind of access.</p>
                </div>
            </section>

            <section id="enums" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">3. Enums: When You Have to Make a Choice</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Some things in the world can only be one of a few options. A light switch is either `On` or `Off`. It can't be both. Using a `bool` (`true`/`false`) works for that. But what if there are three options? Or four?</p>
                    <p>This is where blueprints called **`enum`** (short for enumeration, which means "a numbered list") are perfect. An enum lets you define a custom type that can only be one of its possible variants.</p>
                    <div class="analogy-box">
                        <h3 class="analogy-title">Analogy: The Traffic Light</h3>
                        <p class="mt-2">A traffic light can only be in one of three states. We can make an `enum` for it.
                        <pre class="bg-gray-100 text-gray-800 p-2 rounded">
enum TrafficLight {
    Red,
    Yellow,
    Green,
}</pre>
                        Now, if you have a variable of type `TrafficLight`, the compiler guarantees it can only ever hold one of those three values. You can't accidentally set it to "Blue". This is incredibly safe!
                        </p>
                    </div>
                    <p>For your ESP32, a pin can be an `Input` or an `Output`. For our router, the interface status can be `Up`, `Down`, or `AdminDown`. Let's make a blueprint for that!</p>
                    <div class="code-block"><pre><code class="language-rust">
enum InterfaceStatus {
    Up,
    Down,
    AdminDown,
}

fn main() {
    let status1 = InterfaceStatus::Up;
    let status2 = InterfaceStatus::AdminDown;
}</code></pre></div>

                    <h3 class="text-2xl font-bold text-gray-700 pt-6">Enums with Extra Data</h3>
                    <p>This is where enums become a superpower. Sometimes, a choice comes with extra information. Imagine ordering lunch. Your choice could be `Sandwich`, but that choice needs more data: what kind of bread? what fillings? Or your choice could be `Soup`, and you'd need to know the flavor.</p>
                    <p>An IP Address is a perfect example. The choice is `V4` or `V6`, but each choice comes with different data.</p>
                     <div class="code-block"><pre><code class="language-rust">
enum IpAddress {
    // The V4 variant holds four `u8` numbers (like 192.168.1.1)
    V4(u8, u8, u8, u8), 
    // The V6 variant holds a single `String`
    V6(String),
}

fn main() {
    // Here, the choice is V4, and the extra data is 127, 0, 0, 1.
    let localhost_v4 = IpAddress::V4(127, 0, 0, 1);

    // Here, the choice is V6, and the extra data is the text "::1".
    let localhost_v6 = IpAddress::V6(String::from("::1"));
}</code></pre></div>
                </div>
            </section>
            
            <section id="match" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">4. `match`: The Super-Smart Sorting Machine</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>Now that we have these choices, how do we get the computer to do different things for each choice? We use a tool called **`match`**.</p>
                     <div class="analogy-box">
                        <h3 class="analogy-title">Analogy: The LEGO Sorting Machine</h3>
                        <p class="mt-2">Imagine a machine that sorts LEGOs. It has a conveyor belt and different bins. 
                        <ul>
                            <li>If it sees a <strong>Red</strong> brick, it puts it in the "Red Bin".</li>
                            <li>If it sees a <strong>Blue</strong> brick, it puts it in the "Blue Bin".</li>
                        </ul>
                        The `match` keyword is like this sorting machine. But it has a very important safety rule: <strong>you must have a bin for every possible color.</strong> If you build a machine that only has bins for Red and Blue, and a Yellow brick comes down the conveyor, the machine will stop and alert you: "Hey! You forgot to tell me what to do with Yellow bricks!" This is the Rust compiler saving you from bugs.
                        </p>
                    </div>
                    <p>Let's use our `match` sorting machine on the `IpAddress` enum.</p>
                     <div class="code-block"><pre><code class="language-rust">
// (Assuming IpAddress enum is defined above)

fn print_ip(ip: IpAddress) {
    // `match` will look at the `ip` variable...
    match ip {
        // If it's the `V4` variant, put it in this "bin".
        // Also, give us the extra data inside, and we'll call them o1, o2, o3, o4.
        IpAddress::V4(o1, o2, o3, o4) => {
            println!("This is an IPv4 address: {}.{}.{}.{}", o1, o2, o3, o4);
        }
        // If it's the `V6` variant, put it in this "bin".
        // Give us the String inside and we'll call it `address`.
        IpAddress::V6(address) => {
            println!("This is an IPv6 address: {}", address);
        }
    }
}</code></pre></div>
                    <p>Because we told the computer what to do for `V4` AND for `V6`, the compiler is happy. We didn't forget any possibilities.</p>
                </div>
            </section>
            
            <section id="project" class="scroll-mt-20">
                <h2 class="text-3xl font-bold text-gray-700 border-b-2 border-gray-200 pb-3 mb-6">5. Project: Building the Full Router Blueprint</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>It's time to put all our new LEGO pieces together. We will build a full blueprint for our router, using structs that contain enums, and methods that use `match`. This is how real, safe systems are built.</p>
                    <div class="exercise">
                        <h4 class="font-bold text-lg text-yellow-900">Your Task: Assemble the Router Model</h4>
                        <ol class="list-decimal list-inside mt-3 space-y-2 text-yellow-800">
                            <li>Create a new project: `cargo new router_blueprint`.</li>
                            <li>Replace the code in `src/main.rs` with the final code below.</li>
                            <li>Read every comment. See how the `Interface` struct uses the `InterfaceStatus` and `IpAddress` enums as some of its "parts".</li>
                            <li>Run the project with `cargo run` and see your blueprints come to life.</li>
                        </ol>
                        <h4>Final Code: `src/main.rs`</h4>
                        <div class="code-block"><pre><code class="language-rust">
// Blueprint for a choice of statuses
enum InterfaceStatus {
    Up,
    Down,
    AdminDown,
}

// Blueprint for a choice of IP address types, with extra data
enum IpAddress {
    V4(u8, u8, u8, u8),
    V6(String),
}

// Our main blueprint for a network interface.
// It's built out of other custom pieces!
struct Interface {
    name: String,
    status: InterfaceStatus,
    ip: Option&lt;IpAddress&gt;, // An interface might not have an IP!
}

// The instruction manual for our Interface blueprint
impl Interface {
    fn print_status(&self) {
        // A sorting machine for the status
        let status_str = match self.status {
            InterfaceStatus::Up => "Connected",
            InterfaceStatus::Down => "Link Down",
            InterfaceStatus::AdminDown => "Turned Off by Admin",
        };

        // A sorting machine for the IP address.
        // `Option` is an enum with two choices: `Some(data)` or `None`.
        let ip_str = match &self.ip {
            Some(IpAddress::V4(o1, o2, o3, o4)) => format!("{}.{}.{}.{}", o1, o2, o3, o4),
            Some(IpAddress::V6(addr)) => addr.clone(),
            None => String::from("No IP assigned"),
        };
        
        println!("- {}: Status is {}, IP is {}", self.name, status_str, ip_str);
    }
}

fn main() {
    println!("Kampala Core Router Status Report:");

    // Build our first interface instance
    let gig0_1 = Interface {
        name: String::from("GigabitEthernet0/1 (Uplink)"),
        status: InterfaceStatus::Up,
        ip: Some(IpAddress::V4(10, 40, 1, 1)),
    };
    
    // Build our second interface instance
    let gig0_2 = Interface {
        name: String::from("GigabitEthernet0/2 (Local)"),
        status: InterfaceStatus::AdminDown,
        ip: None, // This interface has no IP. `None` is a safe way to say "nothing here".
    };

    gig0_1.print_status();
    gig0_2.print_status();
}</code></pre></div>
                    </div>
                </div>
            </section>
            
            <section id="next" class="scroll-mt-20 border-t pt-10">
                <h2 class="text-3xl font-bold text-gray-700">Final Thoughts and a Preamble to Chapter 5</h2>
                <div class="prose max-w-none text-gray-700 space-y-4">
                    <p>You have just learned how to be an architect. You are no longer just using the basic bricks; you are designing and building your own custom components. You can see how these blueprints (`struct` and `enum`) allow you to represent the real world—like your network devices or the sensors on an airplane—in a way that is incredibly safe and clear. The compiler helps you make sure your blueprints are correct and that you never forget a possible choice.</p>
                    <p>But our router is a bit lonely. It only has two interfaces that we built one by one. A real router has a whole list of interfaces. An airplane has a list of sensors. A data center has a list of servers.</p>
                    <p>How do we work with lists and collections of our custom blueprints?</p>
                    <p><strong>In Chapter 5, "Collections and Generics,"</strong> we will learn how to use Rust's built-in "LEGO boxes." We'll explore the `Vec<T>`, a growable list that can hold any number of our `Interface` structs, and the `HashMap<K, V>`, a lookup table for storing data by name. This is the next step in building truly large-scale, powerful systems.</p>
                </div>
            </section>
        </article>
    </div></main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
            const mobileMenuButton = document.getElementById('mobile-menu-button');
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenuButton.addEventListener('click', () => { mobileMenu.classList.toggle('hidden'); });
            document.querySelectorAll('.nav-link-mobile').forEach(link => { link.addEventListener('click', () => { mobileMenu.classList.add('hidden'); }); });
            document.querySelectorAll('.code-block').forEach(block => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.innerText = 'Copy';
                block.appendChild(button);
                button.addEventListener('click', () => {
                    const code = block.querySelector('pre code').innerText;
                    navigator.clipboard.writeText(code).then(() => {
                        button.innerText = 'Copied!';
                        setTimeout(() => { button.innerText = 'Copy'; }, 2000);
                    });
                });
            });
            const sections = document.querySelectorAll('main section[id]');
            const navLinks = document.querySelectorAll('#desktop-nav a.nav-link');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const id = entry.target.getAttribute('id');
                        navLinks.forEach(link => {
                            link.classList.remove('active');
                            if (link.getAttribute('href') === `#${id}`) { link.classList.add('active'); }
                        });
                    }
                });
            }, { rootMargin: "-20% 0px -80% 0px" });
            sections.forEach(section => { observer.observe(section); });
        });
    </script>
</body>
</html>
